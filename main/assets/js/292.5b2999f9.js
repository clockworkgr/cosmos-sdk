(window.webpackJsonp=window.webpackJsonp||[]).push([[292],{816:function(e,t,o){"use strict";o.r(t);var a=o(1),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"store"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#store"}},[e._v("#")]),e._v(" Store")]),e._v(" "),o("p",[e._v("The store package defines the interfaces, types and abstractions for Cosmos SDK\nmodules to read and write to Merkleized state within a Cosmos SDK application.\nThe store package provides many primitives for developers to use in order to\nwork with both state storage and state commitment. Below we describe the various\nabstractions.")]),e._v(" "),o("h2",{attrs:{id:"types"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#types"}},[e._v("#")]),e._v(" Types")]),e._v(" "),o("h3",{attrs:{id:"store-2"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#store-2"}},[e._v("#")]),e._v(" "),o("code",[e._v("Store")])]),e._v(" "),o("p",[e._v("The bulk of the store interfaces are defined "),o("a",{attrs:{href:"https://github.com/cosmos/cosmos-sdk/blob/main/store/types/store.go",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),o("OutboundLink")],1),e._v(",\nwhere the base primitive interface, for which other interfaces build off of, is\nthe "),o("code",[e._v("Store")]),e._v(" type. The "),o("code",[e._v("Store")]),e._v(" interface defines the ability to tell the type of\nthe implementing store and the ability to cache wrap via the "),o("code",[e._v("CacheWrapper")]),e._v(" interface.")]),e._v(" "),o("h3",{attrs:{id:"cachewrapper-cachewrap"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#cachewrapper-cachewrap"}},[e._v("#")]),e._v(" "),o("code",[e._v("CacheWrapper")]),e._v(" & "),o("code",[e._v("CacheWrap")])]),e._v(" "),o("p",[e._v("One of the most important features a store has the ability to perform is the\nability to cache wrap. Cache wrapping is essentially the underlying store wrapping\nitself within another store type that performs caching for both reads and writes\nwith the ability to flush writes via "),o("code",[e._v("Write()")]),e._v(".")]),e._v(" "),o("h3",{attrs:{id:"kvstore-cachekvstore"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#kvstore-cachekvstore"}},[e._v("#")]),e._v(" "),o("code",[e._v("KVStore")]),e._v(" & "),o("code",[e._v("CacheKVStore")])]),e._v(" "),o("p",[e._v("One of the most important interfaces that both developers and modules interface\nwith, which also provides the basis of most state storage and commitment operations,\nis the "),o("code",[e._v("KVStore")]),e._v(". The "),o("code",[e._v("KVStore")]),e._v(" interface provides basic CRUD abilities and\nprefix-based iteration, including reverse iteration.")]),e._v(" "),o("p",[e._v("Typically, each module has it's own dedicated "),o("code",[e._v("KVStore")]),e._v(" instance, which it can\nget access to via the "),o("code",[e._v("sdk.Context")]),e._v(" and the use of a pointer-based named key --\n"),o("code",[e._v("KVStoreKey")]),e._v(". The "),o("code",[e._v("KVStoreKey")]),e._v(" provides pseudo-OCAP. How a exactly a "),o("code",[e._v("KVStoreKey")]),e._v("\nmaps to a "),o("code",[e._v("KVStore")]),e._v(" will be illustrated below through the "),o("code",[e._v("CommitMultiStore")]),e._v(".")]),e._v(" "),o("p",[e._v("Note, a "),o("code",[e._v("KVStore")]),e._v(" cannot directly commit state. Instead, a "),o("code",[e._v("KVStore")]),e._v(" can be wrapped\nby a "),o("code",[e._v("CacheKVStore")]),e._v(" which extends a "),o("code",[e._v("KVStore")]),e._v(" and provides the ability for the\ncaller to execute "),o("code",[e._v("Write()")]),e._v(" which commits state to the underlying state storage.\nNote, this doesn't actually flush writes to disk as writes are held in memory\nuntil "),o("code",[e._v("Commit()")]),e._v(" is called on the "),o("code",[e._v("CommitMultiStore")]),e._v(".")]),e._v(" "),o("h3",{attrs:{id:"commitmultistore"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#commitmultistore"}},[e._v("#")]),e._v(" "),o("code",[e._v("CommitMultiStore")])]),e._v(" "),o("p",[e._v("The "),o("code",[e._v("CommitMultiStore")]),e._v(" interface exposes the the top-level interface that is used\nto manage state commitment and storage by an SDK application and abstracts the\nconcept of multiple "),o("code",[e._v("KVStore")]),e._v("s which are used by multiple modules. Specifically,\nit supports the following high-level primitives:")]),e._v(" "),o("ul",[o("li",[e._v("Allows for a caller to retrieve a "),o("code",[e._v("KVStore")]),e._v(" by providing a "),o("code",[e._v("KVStoreKey")]),e._v(".")]),e._v(" "),o("li",[e._v("Exposes pruning mechanisms to remove state pinned against a specific height/version\nin the past.")]),e._v(" "),o("li",[e._v("Allows for loading state storage at a particular height/version in the past to\nprovide current head and historical queries.")]),e._v(" "),o("li",[e._v("Provides the ability to rollback state to a previous height/version.")]),e._v(" "),o("li",[e._v("Provides the ability to to load state storage at a particular height/version\nwhile also performing store upgrades, which are used during live hard-fork\napplication state migrations.")]),e._v(" "),o("li",[e._v("Provides the ability to commit all current accumulated state to disk and performs\nMerkle commitment.")])]),e._v(" "),o("h2",{attrs:{id:"implementation-details"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#implementation-details"}},[e._v("#")]),e._v(" Implementation Details")]),e._v(" "),o("p",[e._v("While there are many interfaces that the "),o("code",[e._v("store")]),e._v(" package provides, there is\ntypically a core implementation for each main interface that modules and\ndevelopers interact with that are defined in the Cosmos SDK.")]),e._v(" "),o("h3",{attrs:{id:"iavl-store"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#iavl-store"}},[e._v("#")]),e._v(" "),o("code",[e._v("iavl.Store")])]),e._v(" "),o("p",[e._v("The "),o("code",[e._v("iavl.Store")]),e._v(" provides the core implementation for state storage and commitment\nby implementing the following interfaces:")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("KVStore")])]),e._v(" "),o("li",[o("code",[e._v("CommitStore")])]),e._v(" "),o("li",[o("code",[e._v("CommitKVStore")])]),e._v(" "),o("li",[o("code",[e._v("Queryable")])]),e._v(" "),o("li",[o("code",[e._v("StoreWithInitialVersion")])])]),e._v(" "),o("p",[e._v("It allows for all CRUD operations to be performed along with allowing current\nand historical state queries, prefix iteration, and state commitment along with\nMerkle proof operations. The "),o("code",[e._v("iavl.Store")]),e._v(" also provides the ability to remove\nhistorical state from the state commitment layer.")]),e._v(" "),o("p",[e._v("An overview of the IAVL implementation can be found "),o("a",{attrs:{href:"https://github.com/cosmos/iavl/blob/master/docs/overview.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),o("OutboundLink")],1),e._v(".\nIt is important to note that the IAVL store provides both state commitment and\nlogical storage operations, which comes with drawbacks as there are various\nperformance impacts, some of which are very drastic, when it comes to the\noperations mentioned above.")]),e._v(" "),o("p",[e._v('When dealing with state management in modules and clients, the Cosmos SDK provides\nvarious layers of abstractions or "store wrapping", where the '),o("code",[e._v("iavl.Store")]),e._v(" is the\nbottom most layer. When requesting a store to perform reads or writes in a module,\nthe typical abstraction layer in order is defined as follows:")]),e._v(" "),o("tm-code-block",{staticClass:"codeblock",attrs:{language:"text",base64:"aWF2bC5TdG9yZSAmbHQ7LSBjYWNoZWt2LlN0b3JlICZsdDstIGdhc2t2LlN0b3JlICZsdDstIGNhY2hlbXVsdGkuU3RvcmUgJmx0Oy0gcm9vdG11bHRpLlN0b3JlCg=="}}),e._v(" "),o("h3",{attrs:{id:"concurrent-use-of-iavl-store"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#concurrent-use-of-iavl-store"}},[e._v("#")]),e._v(" Concurrent use of IAVL store")]),e._v(" "),o("p",[e._v("The tree under "),o("code",[e._v("iavl.Store")]),e._v(" is not safe for concurrent use. It is the\nresponsibility of the caller to ensure that concurrent access to the store is\nnot performed.")]),e._v(" "),o("p",[e._v("The main issue with concurrent use is when data is written at the same time as\nit's being iterated over. Doing so will cause a irrecoverable fatal error because\nof concurrent reads and writes to an internal map.")]),e._v(" "),o("p",[e._v('Although it\'s not recommended, you can iterate through values while writing to\nit by disabling "FastNode" '),o("strong",[e._v("without guarantees that the values being written will\nbe returned during the iteration")]),e._v(" (if you need this, you might want to reconsider\nthe design of your application). This is done by setting "),o("code",[e._v("iavl-disable-fastnode")]),e._v("\nto "),o("code",[e._v("true")]),e._v(" in the config TOML file.")]),e._v(" "),o("h3",{attrs:{id:"cachekv-store"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#cachekv-store"}},[e._v("#")]),e._v(" "),o("code",[e._v("cachekv.Store")])]),e._v(" "),o("p",[e._v("The "),o("code",[e._v("cachekv.Store")]),e._v(" store wraps an underlying "),o("code",[e._v("KVStore")]),e._v(", typically a "),o("code",[e._v("iavl.Store")]),e._v("\nand contains an in-memory cache for storing pending writes to underlying "),o("code",[e._v("KVStore")]),e._v(".\n"),o("code",[e._v("Set")]),e._v(" and "),o("code",[e._v("Delete")]),e._v(" calls are executed on the in-memory cache, whereas "),o("code",[e._v("Has")]),e._v(" calls\nare proxied to the underlying "),o("code",[e._v("KVStore")]),e._v(".")]),e._v(" "),o("p",[e._v("One of the most important calls to a "),o("code",[e._v("cachekv.Store")]),e._v(" is "),o("code",[e._v("Write()")]),e._v(", which ensures\nthat key-value pairs are written to the underlying "),o("code",[e._v("KVStore")]),e._v(' in a deterministic\nand ordered manner by sorting the keys first. The store keeps track of "dirty"\nkeys and uses these to determine what keys to sort. In addition, it also keeps\ntrack of deleted keys and ensures these are also removed from the underlying\n'),o("code",[e._v("KVStore")]),e._v(".")]),e._v(" "),o("p",[e._v("The "),o("code",[e._v("cachekv.Store")]),e._v(" also provides the ability to perform iteration and reverse\niteration. Iteration is performed through the "),o("code",[e._v("cacheMergeIterator")]),e._v(" type and uses\nboth the dirty cache and underlying "),o("code",[e._v("KVStore")]),e._v(" to iterate over key-value pairs.")]),e._v(" "),o("p",[e._v("Note, all calls to CRUD and iteration operations on a "),o("code",[e._v("cachekv.Store")]),e._v(" are thread-safe.")]),e._v(" "),o("h3",{attrs:{id:"gaskv-store"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#gaskv-store"}},[e._v("#")]),e._v(" "),o("code",[e._v("gaskv.Store")])]),e._v(" "),o("p",[e._v("The "),o("code",[e._v("gaskv.Store")]),e._v(" store provides a simple implementation of a "),o("code",[e._v("KVStore")]),e._v(".\nSpecifically, it just wraps an existing "),o("code",[e._v("KVStore")]),e._v(", such as a cache-wrapped\n"),o("code",[e._v("iavl.Store")]),e._v(", and incurs configurable gas costs for CRUD operations via\n"),o("code",[e._v("ConsumeGas()")]),e._v(" calls defined on the "),o("code",[e._v("GasMeter")]),e._v(" which exists in a "),o("code",[e._v("sdk.Context")]),e._v("\nand then proxies the underlying CRUD call to the underlying store. Note, the\n"),o("code",[e._v("GasMeter")]),e._v(" is reset on each block.")]),e._v(" "),o("h3",{attrs:{id:"cachemulti-store-rootmulti-store"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#cachemulti-store-rootmulti-store"}},[e._v("#")]),e._v(" "),o("code",[e._v("cachemulti.Store")]),e._v(" & "),o("code",[e._v("rootmulti.Store")])]),e._v(" "),o("p",[e._v("The "),o("code",[e._v("rootmulti.Store")]),e._v(" acts as an abstraction around a series of stores. Namely,\nit implements the "),o("code",[e._v("CommitMultiStore")]),e._v(" an "),o("code",[e._v("Queryable")]),e._v(" interfaces. Through the\n"),o("code",[e._v("rootmulti.Store")]),e._v(", an SDK module can request access to a "),o("code",[e._v("KVStore")]),e._v(" to perform\nstate CRUD operations and queries by holding access to a unique "),o("code",[e._v("KVStoreKey")]),e._v(".")]),e._v(" "),o("p",[e._v("The "),o("code",[e._v("rootmulti.Store")]),e._v(" ensures these queries and state operations are performed\nthrough cached-wrapped instances of "),o("code",[e._v("cachekv.Store")]),e._v(" which is described above. The\n"),o("code",[e._v("rootmulti.Store")]),e._v(" implementation is also responsible for committing all accumulated\nstate from each "),o("code",[e._v("KVStore")]),e._v(" to disk and returning an application state Merkle root.")]),e._v(" "),o("p",[e._v("Queries can be performed to return state data along with associated state\ncommitment proofs for both previous heights/versions and the current state root.\nQueries are routed based on store name, i.e. a module, along with other parameters\nwhich are defined in "),o("code",[e._v("abci.RequestQuery")]),e._v(".")]),e._v(" "),o("p",[e._v("The "),o("code",[e._v("rootmulti.Store")]),e._v(" also provides primitives for pruning data at a given\nheight/version from state storage. When a height is committed, the "),o("code",[e._v("rootmulti.Store")]),e._v("\nwill determine if other previous heights should be considered for removal based\non the operator's pruning settings defined by "),o("code",[e._v("PruningOptions")]),e._v(', which defines\nhow many recent versions to keep on disk and the interval at which to remove\n"staged" pruned heights from disk. During each interval, the staged heights are\nremoved from each '),o("code",[e._v("KVStore")]),e._v(". Note, it is up to the underlying "),o("code",[e._v("KVStore")]),e._v("\nimplementation to determine how pruning is actually performed. The "),o("code",[e._v("PruningOptions")]),e._v("\nare defined as follows:")]),e._v(" "),o("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"dHlwZSBQcnVuaW5nT3B0aW9ucyBzdHJ1Y3QgewoJLy8gS2VlcFJlY2VudCBkZWZpbmVzIGhvdyBtYW55IHJlY2VudCBoZWlnaHRzIHRvIGtlZXAgb24gZGlzay4KCUtlZXBSZWNlbnQgdWludDY0CgoJLy8gSW50ZXJ2YWwgZGVmaW5lcyB3aGVuIHRoZSBwcnVuZWQgaGVpZ2h0cyBhcmUgcmVtb3ZlZCBmcm9tIGRpc2suCglJbnRlcnZhbCB1aW50NjQKCgkvLyBTdHJhdGVneSBkZWZpbmVzIHRoZSBraW5kIG9mIHBydW5pbmcgc3RyYXRlZ3kuIFNlZSBiZWxvdyBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBlYWNoLgoJU3RyYXRlZ3kgUHJ1bmluZ1N0cmF0ZWd5Cn0K"}}),e._v(" "),o("p",[e._v('The Cosmos SDK defines a preset number of pruning "strategies": '),o("code",[e._v("default")]),e._v(", "),o("code",[e._v("everything")]),e._v(" "),o("code",[e._v("nothing")]),e._v(", and "),o("code",[e._v("custom")]),e._v(".")]),e._v(" "),o("p",[e._v("It is important to note that the "),o("code",[e._v("rootmulti.Store")]),e._v(" considers each "),o("code",[e._v("KVStore")]),e._v(" as a\nseparate logical store. In other words, they do not share a Merkle tree or\ncomparable data structure. This means that when state is committed via\n"),o("code",[e._v("rootmulti.Store")]),e._v(", each store is committed in sequence and thus is not atomic.")]),e._v(" "),o("p",[e._v("In terms of store construction and wiring, each Cosmos SDK application contains\na "),o("code",[e._v("BaseApp")]),e._v(" instance which internally has a reference to a "),o("code",[e._v("CommitMultiStore")]),e._v("\nthat is implemented by a "),o("code",[e._v("rootmulti.Store")]),e._v(". The application then registers one or\nmore "),o("code",[e._v("KVStoreKey")]),e._v(" that pertain to a unique module and thus a "),o("code",[e._v("KVStore")]),e._v(". Through\nthe use of an "),o("code",[e._v("sdk.Context")]),e._v(" and a "),o("code",[e._v("KVStoreKey")]),e._v(", each module can get direct access\nto it's respective "),o("code",[e._v("KVStore")]),e._v(" instance.")]),e._v(" "),o("p",[e._v("Example:")]),e._v(" "),o("tm-code-block",{staticClass:"codeblock",attrs:{language:"golang",base64:"ZnVuYyBOZXdBcHAoLi4uKSBBcHBsaWNhdGlvbiB7CiAgLy8gLi4uCiAgCiAgYkFwcCA6PSBiYXNlYXBwLk5ld0Jhc2VBcHAoYXBwTmFtZSwgbG9nZ2VyLCBkYiwgdHhDb25maWcuVHhEZWNvZGVyKCksIGJhc2VBcHBPcHRpb25zLi4uKQogIGJBcHAuU2V0Q29tbWl0TXVsdGlTdG9yZVRyYWNlcih0cmFjZVN0b3JlKQogIGJBcHAuU2V0VmVyc2lvbih2ZXJzaW9uLlZlcnNpb24pCiAgYkFwcC5TZXRJbnRlcmZhY2VSZWdpc3RyeShpbnRlcmZhY2VSZWdpc3RyeSkKCgkvLyAuLi4KCiAga2V5cyA6PSBzZGsuTmV3S1ZTdG9yZUtleXMoLi4uKQoJdHJhbnNpZW50S2V5cyA6PSBzZGsuTmV3VHJhbnNpZW50U3RvcmVLZXlzKC4uLikKCW1lbUtleXMgOj0gc2RrLk5ld01lbW9yeVN0b3JlS2V5cyguLi4pCgoJLy8gLi4uCgoJLy8gaW5pdGlhbGl6ZSBzdG9yZXMKCWFwcC5Nb3VudEtWU3RvcmVzKGtleXMpCglhcHAuTW91bnRUcmFuc2llbnRTdG9yZXModHJhbnNpZW50S2V5cykKCWFwcC5Nb3VudE1lbW9yeVN0b3JlcyhtZW1LZXlzKQoKCS8vIC4uLgp9Cg=="}}),e._v(" "),o("p",[e._v("The "),o("code",[e._v("rootmulti.Store")]),e._v(" itself can be cache-wrapped which returns an instance of a\n"),o("code",[e._v("cachemulti.Store")]),e._v(". For each block, "),o("code",[e._v("BaseApp")]),e._v(" ensures that the proper abstractions\nare created on the "),o("code",[e._v("CommitMultiStore")]),e._v(", i.e. ensuring that the "),o("code",[e._v("rootmulti.Store")]),e._v("\nis cached-wrapped and uses the resulting "),o("code",[e._v("cachemulti.Store")]),e._v(" to be set on the\n"),o("code",[e._v("sdk.Context")]),e._v(" which is then used for block and transaction execution. As a result,\nall state mutations due to block and transaction execution are actually held\nephemerally until "),o("code",[e._v("Commit()")]),e._v(" is called by the ABCI client. This concept is further\nexpanded upon when the AnteHandler is executed per transaction to ensure state\nis not committed for transactions that failed CheckTx.")])],1)}),[],!1,null,null,null);t.default=r.exports}}]);